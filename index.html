<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Phone-AGI Mockup — ループ文章生成器 + 外部解析</title>
  <style>
    :root{
      --bg:#0b0b10; --card:#12121a; --ink:#e8e8f0; --muted:#a8a8c0; --accent:#6b46c1; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, sans-serif}
    header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg, #0b0b10 0%, #0b0b10cc 80%, transparent 100%);backdrop-filter: blur(6px)}
    .wrap{max-width:980px;margin:0 auto;padding:16px}
    h1{font-size:clamp(18px,2.4vw,28px);margin:8px 0}
    p{color:var(--muted);margin:6px 0}
    .grid{display:grid;gap:12px}
    @media (min-width:960px){.grid{grid-template-columns:320px 1fr}}
    .card{background:var(--card);border:1px solid #222336;border-radius:16px;padding:12px;box-shadow:0 10px 30px #0006}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button{appearance:none;border:1px solid #2b2b3e;background:#1a1a27;color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600}
    button.primary{background:var(--accent);border-color:transparent}
    button.ghost{background:transparent}
    button:disabled{opacity:.5;cursor:not-allowed}
    .badge{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid #2b2b3e}
    .ok{color:var(--ok);border-color:#204e2c;background:#0e2114}
    .warn{color:var(--warn);border-color:#4e3d20;background:#221a0e}
    .bad{color:var(--bad);border-color:#4e2020;background:#210e0e}
    video,canvas{width:100%;border-radius:12px;background:#000;display:block;aspect-ratio:4/3}
    meter{width:100%;height:12px}
    .kv{display:grid;grid-template-columns:120px 1fr;gap:6px;font-size:13px}
    textarea{width:100%;min-height:40vh;background:#0e0e15;color:var(--ink);border:1px solid #222336;border-radius:12px;padding:12px;line-height:1.6;resize:vertical}
    .mono{font-family:ui-monospace,SFMono-Regular,Consolas,Menlo,monospace}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border:1px dashed #2b2b3e;border-radius:10px}
    .small{font-size:12px;color:#b9b9cc}
    .muted{color:var(--muted)}
    .hr{height:1px;background:#202233;margin:10px 0;border-radius:1px}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Phone-AGI Mockup（自律思考ふう）— センサー×記憶×<u>外部解析</u> ループ文章生成器</h1>
      <p>スマホの <strong>カメラ/マイク/動きセンサー</strong> と <strong>ローカル記憶</strong>、さらに <strong>外部テキストのキーワード/要約</strong> を混ぜて、<em>シニフィエ⇄意識GUI⇄シニフィアン</em> を再帰ループ。</p>
    </div>
  </header>

  <main class="wrap grid">
    <!-- 左：センサー入力 -->
    <section class="card">
      <div class="row">
        <button id="btnStart" class="primary">▶ Start</button>
        <button id="btnStop" class="ghost" disabled>■ Stop</button>
        <span id="status" class="badge">idle</span>
      </div>
      <div class="hr"></div>

      <div class="row">
        <span class="pill"><input type="checkbox" id="useCam" checked>カメラ</span>
        <span class="pill"><input type="checkbox" id="useMic" checked>マイク</span>
        <span class="pill"><input type="checkbox" id="useMotion" checked>モーション</span>
        <span class="pill"><input type="checkbox" id="useGeo">位置</span>
      </div>

      <div id="camPane" class="row" style="margin-top:8px">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="camCanvas" hidden></canvas>
      </div>

      <div class="kv">
        <div>音量（RMS）</div>
        <div><meter id="vu" min="0" low="0.15" high="0.6" max="1" optimum="0.05" value="0"></meter></div>
        <div>明るさ推定</div>
        <div><span id="bright" class="mono">—</span></div>
        <div>主色（H,S,V）</div>
        <div><span id="domColor" class="mono">—</span></div>
        <div>動き（加速度）</div>
        <div><span id="motion" class="mono">—</span></div>
        <div>位置（緯度,経度,±m）</div>
        <div><span id="geos" class="mono">—</span></div>
      </div>

      <div class="hr"></div>
      <div class="row small">
        <span class="muted">権限ヒント：</span>
        <span>HTTPS必須 / カメラは背面に切替推奨 / iOSはユーザ操作後のみセンサー可。</span>
      </div>
    </section>

    <!-- 中：外部解析（テキストを混ぜる） -->
    <section class="card">
      <div class="row">
        <strong>外部解析</strong>
        <span class="badge" id="extStatus">idle</span>
      </div>
      <div class="hr"></div>
      <textarea id="extText" placeholder="ここに外部テキストを貼り付け→『テキスト解析』でキーワード/要約を抽出し、生成ループに混ぜます。"></textarea>
      <div class="row">
        <button id="btnAnalyze" class="primary">🧠 テキスト解析</button>
        <label class="pill small">重み <input id="extWeight" type="range" min="0" max="1" step="0.05" value="0.6" style="width:160px"></label>
        <span class="small" id="extBrief">—</span>
      </div>
      <div class="hr"></div>
      <div class="small">
        <div><strong>抽出キーワード:</strong> <span id="extKeywords" class="mono muted">—</span></div>
        <div style="margin-top:6px"><strong>要約:</strong>
          <div id="extSummary" class="muted"></div>
        </div>
      </div>
    </section>

    <!-- 右：意識GUI＆文章 -->
    <section class="card">
      <div class="row">
        <button id="btnClearMem" class="ghost">🧹 記憶クリア</button>
        <span class="badge ok" id="memStat">mem:0</span>
        <span class="badge warn">実験的</span>
      </div>
      <div class="hr"></div>
      <div class="row">
        <label class="pill small"><input type="checkbox" id="streamMode" checked> ストリーム出力</label>
        <label class="pill small"><input type="checkbox" id="autoScroll" checked> 自動スクロール</label>
        <label class="pill small"><input type="checkbox" id="showThought" checked> メタ思考ログを混ぜる</label>
      </div>
      <textarea id="out" placeholder="ここに“意識 GUI”のテキストが流れます…"></textarea>
      <div class="hr"></div>
      <div class="small">説明：左のセンサー/中段の外部解析から <em>特徴量→シニフィエ</em> を抽出。右のテキストは <em>意識（GUI）</em>。そこから <em>シニフィアン</em> を生成→GUIへ反映→記憶へ保存→次ステップで参照…を1.6秒ピッチで再帰。</div>
    </section>
  </main>

  <script>
  // === 簡易 “記憶” 実装（localStorage） =====================================
  const MEM_KEY = 'phoneAGI:episodes:v1';
  function loadMem(){
    try{ return JSON.parse(localStorage.getItem(MEM_KEY) || '[]'); }catch(e){ return []; }
  }
  function saveMem(arr){ localStorage.setItem(MEM_KEY, JSON.stringify(arr.slice(-400))); }
  function pushEpisode(ep){ const arr = loadMem(); arr.push(ep); saveMem(arr); updateMemBadge(); }
  function updateMemBadge(){ const n = loadMem().length; document.getElementById('memStat').textContent = `mem:${n}`; }

  // === センサー取得（Camera / Mic / Motion / Geo） ==========================
  let mediaStream=null, audioCtx=null, analyser=null, dataArray=null;
  let videoEl = document.getElementById('video');
  let camCanvas = document.getElementById('camCanvas');
  let useCamEl = document.getElementById('useCam');
  let useMicEl = document.getElementById('useMic');
  let useMotionEl = document.getElementById('useMotion');
  let useGeoEl = document.getElementById('useGeo');

  async function startSensors(){
    const wantCam = useCamEl.checked; const wantMic = useMicEl.checked;
    if(wantCam || wantMic){
      mediaStream = await navigator.mediaDevices.getUserMedia({
        video: wantCam ? { facingMode: 'environment' } : false,
        audio: wantMic ? { echoCancellation:true, noiseSuppression:true } : false
      });
      if(wantCam){ videoEl.srcObject = mediaStream; }
      if(wantMic){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const micSrc = audioCtx.createMediaStreamSource(mediaStream);
        analyser = audioCtx.createAnalyser(); analyser.fftSize = 1024;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        micSrc.connect(analyser);
      }
    }

    if(useMotionEl.checked && 'DeviceMotionEvent' in window){
      if(DeviceMotionEvent.requestPermission){
        try{ await DeviceMotionEvent.requestPermission(); }catch(e){ console.warn('motion perm',e); }
      }
      window.addEventListener('devicemotion', onMotion);
    }

    if(useGeoEl.checked && 'geolocation' in navigator){
      geoWatchId = navigator.geolocation.watchPosition(onGeo, err=>console.warn(err), {enableHighAccuracy:true, maximumAge:5000});
    }
  }

  async function stopSensors(){
    if(geoWatchId){ navigator.geolocation.clearWatch(geoWatchId); geoWatchId = null; }
    window.removeEventListener('devicemotion', onMotion);
    if(analyser){ analyser.disconnect(); analyser=null; }
    if(audioCtx){ audioCtx.close(); audioCtx=null; }
    if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
    videoEl.srcObject=null;
  }

  // === 特徴量抽出（カメラ：明るさ/主色, マイク：RMS, モーション：加速度） ===
  const feat = { bright: null, hsv: null, rms: 0, accel: 0, geo: null };
  let geoWatchId=null;
  function onMotion(e){
    const ax = e.accelerationIncludingGravity?.x||0,
          ay = e.accelerationIncludingGravity?.y||0,
          az = e.accelerationIncludingGravity?.z||0;
    feat.accel = Math.min(1, Math.sqrt(ax*ax+ay*ay+az*az)/30);
    document.getElementById('motion').textContent = feat.accel.toFixed(3);
  }
  function onGeo(pos){
    const {latitude, longitude, accuracy} = pos.coords;
    feat.geo = {lat: latitude, lon: longitude, acc: accuracy};
    document.getElementById('geos').textContent = `${latitude.toFixed(5)}, ${longitude.toFixed(5)}, ±${Math.round(accuracy)}m`;
  }

  function sampleCamera(){
    if(!videoEl.videoWidth) return;
    const w = 160, h = Math.round(w*videoEl.videoHeight/videoEl.videoWidth);
    camCanvas.width = w; camCanvas.height = h; const ctx = camCanvas.getContext('2d');
    ctx.drawImage(videoEl, 0, 0, w, h);
    const img = ctx.getImageData(0,0,w,h).data;
    let sum=0; for(let i=0;i<img.length;i+=4){ const r=img[i],g=img[i+1],b=img[i+2]; const y=0.2126*r+0.7152*g+0.0722*b; sum+=y; }
    const bright = sum/(img.length/4)/255; feat.bright = bright; document.getElementById('bright').textContent = bright.toFixed(3);
    let H=0,S=0,V=0,N=0;
    for(let i=0;i<img.length;i+=16){
      const r=img[i]/255, g=img[i+1]/255, b=img[i+2]/255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b); const v=max; const d=max-min;
      let h=0; if(d===0) h=0; else if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0) h+=360;
      const s = max===0?0:d/max;
      H+=h; S+=s; V+=v; N++;
    }
    H/=N; S/=N; V/=N; feat.hsv = {h:Math.round(H), s:+S.toFixed(3), v:+V.toFixed(3)};
    document.getElementById('domColor').textContent = `${feat.hsv.h}°, ${feat.hsv.s}, ${feat.hsv.v}`;
  }

  function sampleMic(){
    if(!analyser) return; analyser.getByteTimeDomainData(dataArray);
    let sum=0; for(let i=0;i<dataArray.length;i++){ const v=(dataArray[i]-128)/128; sum+=v*v; }
    const rms = Math.min(1, Math.sqrt(sum/dataArray.length)); feat.rms = rms; document.getElementById('vu').value = rms;
  }

  // === “意味生成(シニフィエ)”：センサー→記述子 =================================
  function signifiedFromFeatures(f){
    const tags=[];
    if(f.bright!=null){ if(f.bright<0.2) tags.push('暗'); else if(f.bright<0.5) tags.push('穏'); else tags.push('明'); }
    if(f.hsv){ const {h,s,v}=f.hsv; if(s<0.2) tags.push('無彩'); else if(h<30||h>330) tags.push('赤'); else if(h<90) tags.push('黄緑'); else if(h<150) tags.push('緑'); else if(h<210) tags.push('青'); else if(h<270) tags.push('藍'); else tags.push('紫'); }
    if(f.rms!=null){ if(f.rms<0.05) tags.push('静'); else if(f.rms<0.2) tags.push('柔'); else tags.push('喧'); }
    if(f.accel!=null){ if(f.accel<0.05) tags.push('止'); else if(f.accel<0.2) tags.push('揺'); else tags.push('奔'); }
    if(f.geo){ tags.push(`@${f.geo.lat.toFixed(2)},${f.geo.lon.toFixed(2)}`); }
    return tags; // これが“シニフィエ”候補
  }

  // === 外部解析ユーティリティ（ローカル軽量） ================================
  const jaStop = new Set(['こと','もの','よう','ため','それ','これ','あれ','ので','です','ます','する','いる','ある','なる','そして','また','ので','から','たり','だが','しかし','により','など','なら','では','ではない','ない','的','的な','的に']);
  const enStop = new Set(['the','a','an','and','or','but','to','of','in','on','for','with','as','is','are','was','were','be','been','being','by','at','from','that','this','it','its','into']);
  let externalCtx = { keywords:[], summary:[], tags:[], weight:0.6 };
  function tokenizeJaEn(text){
    const tokens = (text.toLowerCase().match(/[\p{Script=Han}\p{Script=Hiragana}\p{Script=Katakana}a-z0-9]{2,}/gu) || []);
    return tokens.filter(t=>!jaStop.has(t)&&!enStop.has(t));
  }
  function extractKeywords(text, topN=12){
    const freq = new Map();
    for(const t of tokenizeJaEn(text)){ freq.set(t, (freq.get(t)||0)+1); }
    return Array.from(freq.entries()).sort((a,b)=>b[1]-a[1]).slice(0,topN).map(([k])=>k);
  }
  function splitSentences(text){ return (text.match(/[^。.!?\n]+[。.!?]?/g) || []).map(s=>s.trim()).filter(Boolean); }
  function summarize(text, kwords){
    const sents = splitSentences(text);
    const scored = sents.map(s=>({s,score:kwords.reduce((acc,w)=>acc+(s.includes(w)?1:0),0)}));
    return scored.sort((a,b)=>b.score-a.score).slice(0,3).map(o=>o.s);
  }
  function updateExternalCtxFromText(text){
    const kws = extractKeywords(text, 12);
    const sum = summarize(text, kws);
    externalCtx.keywords = kws;
    externalCtx.summary = sum;
    externalCtx.tags = kws.slice(0,5).map(w=>`外:${w}`);
    const kwEl = document.getElementById('extKeywords'); if(kwEl) kwEl.textContent = kws.join(', ');
    const sumEl = document.getElementById('extSummary'); if(sumEl) sumEl.innerHTML = sum.map(s=>`• ${s}`).join('<br>');
    const brEl = document.getElementById('extBrief'); if(brEl) brEl.textContent = `k=${kws.length} / s=${sum.length}`;
    const stEl = document.getElementById('extStatus'); if(stEl) stEl.textContent = 'analyzed';
  }

  // === “記号化(シニフィアン)”：テンプレ生成器 ==================================
  const TEMPLATES = [
    ({tags,lastLine})=>`いまの場は「${tags.join('・')}」。${pick([
      '身体が先に反応している。','思考は半歩遅れて追いつく。','手触りが意味を先導する。'])}`,
    ({tags})=>`視覚は ${tags.includes('明')?'明滅の粒':'影の縁'} を拾い、聴覚は ${tags.includes('喧')?'街のうねり':'呼吸のリズム'} を数える。`,
    ({tags})=>`${pick(['名づける前の感触が','比喩の手前で','語の輪郭より前に'])} 立ち上がる合意を、ここでは “暫定の意味” と呼ぶ。`,
    ({tags})=>`GUI（意識）は、その暫定を <記憶> に押しピンで留める（${new Date().toLocaleTimeString()}）。`,
    ({tags,lastLine})=>`さっきの文は ${pick(['別の文になりたがっている','まだ言い足りない顔をしている','次の比喩を要求している'])}。${lastLine?`「${lastLine.slice(0,24)}…」の裏側で発酵が続く。`:''}`,
    ({tags})=>`ここで操作は不要。センサーが流れ、意味は巡回し、記号が更新される。`,
    ({tags})=>`${pick(['窓の外の温度','ポケットの振動','足下の慣性'])} が一句を修正し、文脈が再配線される。`,
    ({tags})=>`そしてループは続く——<シニフィエ> → <GUI> → <シニフィアン> → <記憶> → <シニフィエ> …。`
  ];
  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function materializeSignifier(ctx){
    const {tags,lastLine} = ctx;
    const pool = [];
    if(externalCtx.summary && externalCtx.summary.length){
      pool.push(`外部の話題（${externalCtx.keywords.slice(0,3).join(' / ')}）が背後で鳴っている。GUIはそれを参照しつつ現在地を書き換える。`);
      pool.push(`要約：${externalCtx.summary.join(' / ')}`);
    }
    for(const t of TEMPLATES){ const line = t({tags,lastLine}); if(line) pool.push(line); }
    const pickable = pool.filter(Boolean);
    return pickable[Math.floor(Math.random()*pickable.length)] || '（…）';
  }

  // === ループ制御：意識GUIのテキストを更新し続ける ============================
  let running=false, stepTimer=null; let lastLine='';
  const outEl = document.getElementById('out');
  const statusEl = document.getElementById('status');

  function appendOut(line, meta){
    const showThought = document.getElementById('showThought').checked;
    const asStream = document.getElementById('streamMode').checked;
    const stamp = new Date().toISOString().slice(11,19);
    const thought = showThought?`\n[meta ${stamp}] ${JSON.stringify(meta)}`:'';
    if(asStream){ outEl.value += `\n${line}${thought}`; }
    else{ outEl.value = `${line}${thought}\n\n` + outEl.value; }
    if(document.getElementById('autoScroll').checked){ outEl.scrollTop = outEl.scrollHeight; }
  }

  function loopTick(){
    sampleCamera(); sampleMic();
    const tagsNow = signifiedFromFeatures(feat);

    const mem = loadMem();
    const recent = mem.slice(-5).flatMap(m=>m.tags||[]);

    // 外部タグ（重みで確率採用）
    const w = externalCtx.weight ?? 0.6;
    const ext = externalCtx.tags || [];
    const extPick = ext.filter(()=>Math.random()<w);

    const mergedTags = Array.from(new Set([...tagsNow, ...recent, ...extPick]));

    const line = materializeSignifier({tags:mergedTags,lastLine});

    appendOut(line, {tags:mergedTags, bright:feat.bright, rms:feat.rms, accel:feat.accel, ext:externalCtx.keywords.slice(0,5)});
    lastLine = line;

    pushEpisode({t:Date.now(), tags:tagsNow, feat:{...feat}, ext:extPick, line});
  }

  function startLoop(){
    if(running) return; running=true; statusEl.textContent='running';
    stepTimer = setInterval(loopTick, 1600);
  }
  function stopLoop(){
    running=false; statusEl.textContent='stopped';
    if(stepTimer){ clearInterval(stepTimer); stepTimer=null; }
  }

  // === UI配線 ================================================================
  document.getElementById('btnStart').addEventListener('click', async ()=>{
    document.getElementById('btnStart').disabled = true;
    document.getElementById('btnStop').disabled = false;
    await startSensors();
    startLoop();
  });
  document.getElementById('btnStop').addEventListener('click', async ()=>{
    document.getElementById('btnStart').disabled = false;
    document.getElementById('btnStop').disabled = true;
    stopLoop();
    await stopSensors();
  });
  document.getElementById('btnClearMem').addEventListener('click', ()=>{ saveMem([]); updateMemBadge(); });

  // 外部解析 UI
  const extWeightEl = document.getElementById('extWeight');
  if(extWeightEl){ extWeightEl.addEventListener('input', (e)=>{ externalCtx.weight = parseFloat(e.target.value); }); }
  const analyzeBtn = document.getElementById('btnAnalyze');
  if(analyzeBtn){ analyzeBtn.addEventListener('click', ()=>{
    const t = document.getElementById('extText').value.trim();
    if(!t){ const stEl = document.getElementById('extStatus'); if(stEl) stEl.textContent='no text'; return; }
    updateExternalCtxFromText(t);
  }); }

  updateMemBadge();
  </script>
</body>
</html>
