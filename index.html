<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Phone‑AGI Mockup — ループ文章生成器</title>
  <style>
    :root{
      --bg:#0b0b10; --card:#12121a; --ink:#e8e8f0; --muted:#a8a8c0; --accent:#6b46c1; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, sans-serif}
    header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg, #0b0b10 0%, #0b0b10cc 80%, transparent 100%);backdrop-filter: blur(6px)}
    .wrap{max-width:980px;margin:0 auto;padding:16px}
    h1{font-size:clamp(18px,2.4vw,28px);margin:8px 0}
    p{color:var(--muted);margin:6px 0}
    .grid{display:grid;gap:12px}
    @media (min-width:960px){.grid{grid-template-columns:320px 1fr}}
    .card{background:var(--card);border:1px solid #222336;border-radius:16px;padding:12px;box-shadow:0 10px 30px #0006}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button{appearance:none;border:1px solid #2b2b3e;background:#1a1a27;color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600}
    button.primary{background:var(--accent);border-color:transparent}
    button.ghost{background:transparent}
    button:disabled{opacity:.5;cursor:not-allowed}
    .badge{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid #2b2b3e}
    .ok{color:var(--ok);border-color:#204e2c;background:#0e2114}
    .warn{color:var(--warn);border-color:#4e3d20;background:#221a0e}
    .bad{color:var(--bad);border-color:#4e2020;background:#210e0e}
    video,canvas{width:100%;border-radius:12px;background:#000;display:block;aspect-ratio:4/3}
    meter{width:100%;height:12px}
    .kv{display:grid;grid-template-columns:120px 1fr;gap:6px;font-size:13px}
    textarea{width:100%;min-height:40vh;background:#0e0e15;color:var(--ink);border:1px solid #222336;border-radius:12px;padding:12px;line-height:1.6;resize:vertical}
    .mono{font-family:ui-monospace,SFMono-Regular,Consolas,Menlo,monospace}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border:1px dashed #2b2b3e;border-radius:10px}
    .small{font-size:12px;color:#b9b9cc}
    .muted{color:var(--muted)}
    .hr{height:1px;background:#202233;margin:10px 0;border-radius:1px}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Phone‑AGI Mockup（自律思考ふう）— センサー×記憶×再帰 ループ文章生成器</h1>
      <p>スマホの <strong>カメラ/マイク/動きセンサー</strong> と <strong>ローカル記憶</strong> を使い、<em>シニフィエ⇄意識GUI⇄シニフィアン</em> の再帰で長文を自動生成する <span class="badge">ワーキング・モックアップ</span>（ブラウザのみ）。</p>
    </div>
  </header>

  <main class="wrap grid">
    <!-- 左：センサー入力 -->
    <section class="card">
      <div class="row">
        <button id="btnStart" class="primary">▶ Start</button>
        <button id="btnStop" class="ghost" disabled>■ Stop</button>
        <span id="status" class="badge">idle</span>
      </div>
      <div class="hr"></div>

      <div class="row">
        <span class="pill"><input type="checkbox" id="useCam" checked>カメラ</span>
        <span class="pill"><input type="checkbox" id="useMic" checked>マイク</span>
        <span class="pill"><input type="checkbox" id="useMotion" checked>モーション</span>
        <span class="pill"><input type="checkbox" id="useGeo">位置</span>
      </div>

      <div id="camPane" class="row" style="margin-top:8px">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="camCanvas" hidden></canvas>
      </div>

      <div class="kv">
        <div>音量（RMS）</div>
        <div><meter id="vu" min="0" low="0.15" high="0.6" max="1" optimum="0.05" value="0"></meter></div>
        <div>明るさ推定</div>
        <div><span id="bright" class="mono">—</span></div>
        <div>主色（H,S,V）</div>
        <div><span id="domColor" class="mono">—</span></div>
        <div>動き（加速度）</div>
        <div><span id="motion" class="mono">—</span></div>
        <div>位置（緯度,経度,±m）</div>
        <div><span id="geos" class="mono">—</span></div>
      </div>

      <div class="hr"></div>
      <div class="row small">
        <span class="muted">権限ヒント：</span>
        <span>HTTPS必須 / カメラは背面に切替推奨 / iOSはユーザ操作後のみセンサー可。</span>
      </div>
    </section>

    <!-- 右：意識GUI＆文章 -->
    <section class="card">
      <div class="row">
        <button id="btnClearMem" class="ghost">🧹 記憶クリア</button>
        <span class="badge ok" id="memStat">mem:0</span>
        <span class="badge warn">実験的</span>
      </div>
      <div class="hr"></div>
      <div class="row">
        <label class="pill small"><input type="checkbox" id="streamMode" checked> ストリーム出力</label>
        <label class="pill small"><input type="checkbox" id="autoScroll" checked> 自動スクロール</label>
        <label class="pill small"><input type="checkbox" id="showThought" checked> メタ思考ログを混ぜる</label>
      </div>
      <textarea id="out" placeholder="ここに“意識 GUI”のテキストが流れます…"></textarea>
      <div class="hr"></div>
      <div class="small">説明：左のセンサーから <em>特徴量→シニフィエ</em> を抽出。右のテキストは <em>意識（GUI）</em>。そこから <em>シニフィアン</em> を生成し、さらにGUIへ反映→記憶へ保存→次ステップで参照…という再帰ループで“自律っぽく”長文を継続生成します。</div>
    </section>
  </main>

  <script>
  // === 簡易 “記憶” 実装（localStorage） =====================================
  const MEM_KEY = 'phoneAGI:episodes:v1';
  function loadMem(){
    try{ return JSON.parse(localStorage.getItem(MEM_KEY) || '[]'); }catch(e){ return []; }
  }
  function saveMem(arr){ localStorage.setItem(MEM_KEY, JSON.stringify(arr.slice(-400))); }
  function pushEpisode(ep){ const arr = loadMem(); arr.push(ep); saveMem(arr); updateMemBadge(); }
  function updateMemBadge(){ const n = loadMem().length; document.getElementById('memStat').textContent = `mem:${n}`; }

  // === センサー取得（Camera / Mic / Motion / Geo） ==========================
  let mediaStream=null, audioCtx=null, analyser=null, dataArray=null;
  let videoEl = document.getElementById('video');
  let camCanvas = document.getElementById('camCanvas');
  let useCamEl = document.getElementById('useCam');
  let useMicEl = document.getElementById('useMic');
  let useMotionEl = document.getElementById('useMotion');
  let useGeoEl = document.getElementById('useGeo');

  async function startSensors(){
    const wantCam = useCamEl.checked; const wantMic = useMicEl.checked;
    if(wantCam || wantMic){
      mediaStream = await navigator.mediaDevices.getUserMedia({
        video: wantCam ? { facingMode: 'environment' } : false,
        audio: wantMic ? { echoCancellation:true, noiseSuppression:true } : false
      });
      if(wantCam){ videoEl.srcObject = mediaStream; }
      if(wantMic){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const micSrc = audioCtx.createMediaStreamSource(mediaStream);
        analyser = audioCtx.createAnalyser(); analyser.fftSize = 1024;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        micSrc.connect(analyser);
      }
    }

    if(useMotionEl.checked && 'DeviceMotionEvent' in window){
      // iOS13+ はユーザジェスチャ後に permission が必要
      if(DeviceMotionEvent.requestPermission){
        try{ await DeviceMotionEvent.requestPermission(); }catch(e){ console.warn('motion perm',e); }
      }
      window.addEventListener('devicemotion', onMotion);
    }

    if(useGeoEl.checked && 'geolocation' in navigator){
      geoWatchId = navigator.geolocation.watchPosition(onGeo, err=>console.warn(err), {enableHighAccuracy:true, maximumAge:5000});
    }
  }

  async function stopSensors(){
    if(geoWatchId){ navigator.geolocation.clearWatch(geoWatchId); geoWatchId = null; }
    window.removeEventListener('devicemotion', onMotion);
    if(analyser){ analyser.disconnect(); analyser=null; }
    if(audioCtx){ audioCtx.close(); audioCtx=null; }
    if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
    videoEl.srcObject=null;
  }

  // === 特徴量抽出（カメラ：明るさ/主色, マイク：RMS, モーション：加速度） ===
  const feat = { bright: null, hsv: null, rms: 0, accel: 0, geo: null };
  let geoWatchId=null;
  function onMotion(e){
    const ax = e.accelerationIncludingGravity?.x||0,
          ay = e.accelerationIncludingGravity?.y||0,
          az = e.accelerationIncludingGravity?.z||0;
    feat.accel = Math.min(1, Math.sqrt(ax*ax+ay*ay+az*az)/30); // ざっくり正規化
    document.getElementById('motion').textContent = feat.accel.toFixed(3);
  }
  function onGeo(pos){
    const {latitude, longitude, accuracy} = pos.coords;
    feat.geo = {lat: latitude, lon: longitude, acc: accuracy};
    document.getElementById('geos').textContent = `${latitude.toFixed(5)}, ${longitude.toFixed(5)}, ±${Math.round(accuracy)}m`;
  }

  function sampleCamera(){
    if(!videoEl.videoWidth) return;
    const w = 160, h = Math.round(w*videoEl.videoHeight/videoEl.videoWidth);
    camCanvas.width = w; camCanvas.height = h; const ctx = camCanvas.getContext('2d');
    ctx.drawImage(videoEl, 0, 0, w, h);
    const img = ctx.getImageData(0,0,w,h).data;
    // 明るさ（輝度平均）
    let sum=0; for(let i=0;i<img.length;i+=4){ const r=img[i],g=img[i+1],b=img[i+2]; const y=0.2126*r+0.7152*g+0.0722*b; sum+=y; }
    const bright = sum/(img.length/4)/255; feat.bright = bright; document.getElementById('bright').textContent = bright.toFixed(3);
    // 主色（ざっくりHSV平均）
    let H=0,S=0,V=0,N=0;
    for(let i=0;i<img.length;i+=16){ // 4pxに1回で軽量化
      const r=img[i]/255, g=img[i+1]/255, b=img[i+2]/255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b); const v=max; const d=max-min;
      let h=0; if(d===0) h=0; else if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0) h+=360;
      const s = max===0?0:d/max;
      H+=h; S+=s; V+=v; N++;
    }
    H/=N; S/=N; V/=N; feat.hsv = {h:Math.round(H), s:+S.toFixed(3), v:+V.toFixed(3)};
    document.getElementById('domColor').textContent = `${feat.hsv.h}°, ${feat.hsv.s}, ${feat.hsv.v}`;
  }

  function sampleMic(){
    if(!analyser) return; analyser.getByteTimeDomainData(dataArray);
    let sum=0; for(let i=0;i<dataArray.length;i++){ const v=(dataArray[i]-128)/128; sum+=v*v; }
    const rms = Math.min(1, Math.sqrt(sum/dataArray.length)); feat.rms = rms; document.getElementById('vu').value = rms;
  }

  // === “意味生成(シニフィエ)”：センサー→記述子 =================================
  function signifiedFromFeatures(f){
    const tags=[];
    if(f.bright!=null){ if(f.bright<0.2) tags.push('暗'); else if(f.bright<0.5) tags.push('穏'); else tags.push('明'); }
    if(f.hsv){ const {h,s,v}=f.hsv; if(s<0.2) tags.push('無彩'); else if(h<30||h>330) tags.push('赤'); else if(h<90) tags.push('黄緑'); else if(h<150) tags.push('緑'); else if(h<210) tags.push('青'); else if(h<270) tags.push('藍'); else tags.push('紫'); }
    if(f.rms!=null){ if(f.rms<0.05) tags.push('静'); else if(f.rms<0.2) tags.push('柔'); else tags.push('喧'); }
    if(f.accel!=null){ if(f.accel<0.05) tags.push('止'); else if(f.accel<0.2) tags.push('揺'); else tags.push('奔'); }
    if(f.geo){ tags.push(`@${f.geo.lat.toFixed(2)},${f.geo.lon.toFixed(2)}`); }
    return tags; // これが“シニフィエ”候補
  }

  // === “記号化(シニフィアン)”：テンプレ生成器 ==================================
  const TEMPLATES = [
    ({tags,lastLine})=>`いまの場は「${tags.join('・')}」。${pick([
      '身体が先に反応している。','思考は半歩遅れて追いつく。','手触りが意味を先導する。'])}`,
    ({tags})=>`視覚は ${tags.includes('明')?'明滅の粒':'影の縁'} を拾い、聴覚は ${tags.includes('喧')?'街のうねり':'呼吸のリズム'} を数える。`,
    ({tags})=>`${pick(['名づける前の感触が','比喩の手前で','語の輪郭より前に'])} 立ち上がる合意を、ここでは “暫定の意味” と呼ぶ。`,
    ({tags})=>`GUI（意識）は、その暫定を <記憶> に押しピンで留める（${new Date().toLocaleTimeString()}）。`,
    ({tags,lastLine})=>`さっきの文は ${pick(['別の文になりたがっている','まだ言い足りない顔をしている','次の比喩を要求している'])}。${lastLine?`「${lastLine.slice(0,24)}…」の裏側で発酵が続く。`:''}`,
    ({tags})=>`ここで操作は不要。センサーが流れ、意味は巡回し、記号が更新される。`,
    ({tags})=>`${pick(['窓の外の温度','ポケットの振動','足下の慣性'])} が一句を修正し、文脈が再配線される。`,
    ({tags})=>`そしてループは続く——<シニフィエ> → <GUI> → <シニフィアン> → <記憶> → <シニフィエ> …。`
  ];
  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function materializeSignifier(ctx){
    const {tags,lastLine} = ctx;
    const t = TEMPLATES[Math.floor(Math.random()*TEMPLATES.length)];
    return t({tags,lastLine});
  }

  // === ループ制御：意識GUIのテキストを更新し続ける ============================
  let running=false, rafId=null; let stepTimer=null; let lastLine='';
  const outEl = document.getElementById('out');
  const statusEl = document.getElementById('status');

  function appendOut(line, meta){
    const showThought = document.getElementById('showThought').checked;
    const asStream = document.getElementById('streamMode').checked;
    const stamp = new Date().toISOString().slice(11,19);
    const thought = showThought?`\n[meta ${stamp}] ${JSON.stringify(meta)}`:'';
    if(asStream){ outEl.value += `\n${line}${thought}`; }
    else{ outEl.value = `${line}${thought}\n\n` + outEl.value; }
    if(document.getElementById('autoScroll').checked){ outEl.scrollTop = outEl.scrollHeight; }
  }

  function loopTick(){
    // センサーのサンプリング
    sampleCamera(); sampleMic();
    const tags = signifiedFromFeatures(feat);

    // 直近の記憶（エピソード）
    const mem = loadMem();
    const recent = mem.slice(-5).flatMap(m=>m.tags||[]);

    // “自律ふう”決定：いまのタグ + 直近タグの頻度で重み付け
    const mergedTags = Array.from(new Set([...tags, ...recent]));

    // シニフィアン生成
    const line = materializeSignifier({tags:mergedTags,lastLine});

    // GUI更新
    appendOut(line, {tags:mergedTags, bright:feat.bright, rms:feat.rms, accel:feat.accel});
    lastLine = line;

    // 記憶保存
    pushEpisode({t:Date.now(), tags, feat:{...feat}, line});
  }

  function startLoop(){
    if(running) return; running=true; statusEl.textContent='running';
    stepTimer = setInterval(loopTick, 1600); // 1.6s毎に一文
  }
  function stopLoop(){
    running=false; statusEl.textContent='stopped';
    if(stepTimer){ clearInterval(stepTimer); stepTimer=null; }
  }

  // === UI配線 ================================================================
  document.getElementById('btnStart').addEventListener('click', async ()=>{
    document.getElementById('btnStart').disabled = true;
    document.getElementById('btnStop').disabled = false;
    await startSensors();
    startLoop();
  });
  document.getElementById('btnStop').addEventListener('click', async ()=>{
    document.getElementById('btnStart').disabled = false;
    document.getElementById('btnStop').disabled = true;
    stopLoop();
    await stopSensors();
  });
  document.getElementById('btnClearMem').addEventListener('click', ()=>{ saveMem([]); updateMemBadge(); });

  updateMemBadge();
  </script>
</body>
</html>
